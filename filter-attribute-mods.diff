From: Matt McCutchen <matt@mattmccutchen.net>

Implement the "m", "o", "g" include modifiers to tweak the permissions,
owner, or group of matching files.

To use this patch, run these commands for a successful build:

    patch -p1 <patches/filter-attribute-mods.diff
    ./configure                         (optional if already run)
    make

based-on: 3305a7a063ab0167cab5bf7029da53abaa9fdb6e
diff --git a/exclude.c b/exclude.c
--- a/exclude.c
+++ b/exclude.c
@@ -51,12 +51,15 @@ filter_rule_list cvs_filter_list = { .debug_type = " [global CVS]" };
 filter_rule_list daemon_filter_list = { .debug_type = " [daemon]" };
 filter_rule_list implied_filter_list = { .debug_type = " [implied]" };
 
+filter_rule *last_hit_filter_rule;
+
 int saw_xattr_filter = 0;
 int trust_sender_args = 0;
 int trust_sender_filter = 0;
 
-/* Need room enough for ":MODS " prefix plus some room to grow. */
-#define MAX_RULE_PREFIX (16)
+/* Need room enough for ":MODS " prefix, which can now include
+ * chmod/user/group values. */
+#define MAX_RULE_PREFIX (256)
 
 #define SLASH_WILD3_SUFFIX "/***"
 
@@ -139,8 +142,27 @@ static void teardown_mergelist(filter_rule *ex)
 		mergelist_cnt--;
 }
 
+static struct filter_chmod_struct *ref_filter_chmod(struct filter_chmod_struct *chmod)
+{
+	chmod->ref_cnt++;
+	assert(chmod->ref_cnt != 0); /* Catch overflow. */
+	return chmod;
+}
+
+static void unref_filter_chmod(struct filter_chmod_struct *chmod)
+{
+	chmod->ref_cnt--;
+	if (chmod->ref_cnt == 0) {
+		free(chmod->modestr);
+		free_chmod_mode(chmod->modes);
+		free(chmod);
+	}
+}
+
 static void free_filter(filter_rule *ex)
 {
+	if (ex->rflags & FILTRULE_CHMOD)
+		unref_filter_chmod(ex->chmod);
 	if (ex->rflags & FILTRULE_PERDIR_MERGE)
 		teardown_mergelist(ex);
 	free(ex->pattern);
@@ -1006,7 +1028,9 @@ static void report_filter_result(enum logcode code, char const *name,
 
 /* This function is used to check if a file should be included/excluded
  * from the list of files based on its name and type etc.  The value of
- * filter_level is set to either SERVER_FILTERS or ALL_FILTERS. */
+ * filter_level is set to either SERVER_FILTERS or ALL_FILTERS.
+ * "last_hit_filter_rule" will be set to the operative filter, or NULL if none. */
+
 int name_is_excluded(const char *fname, int name_flags, int filter_level)
 {
 	if (daemon_filter_list.head && check_filter(&daemon_filter_list, FLOG, fname, name_flags) < 0) {
@@ -1015,6 +1039,9 @@ int name_is_excluded(const char *fname, int name_flags, int filter_level)
 		return 1;
 	}
 
+	/* Don't leave a daemon include in last_hit_filter_rule. */
+	last_hit_filter_rule = NULL;
+
 	if (filter_level != ALL_FILTERS)
 		return 0;
 
@@ -1034,7 +1061,8 @@ int check_server_filter(filter_rule_list *listp, enum logcode code, const char *
 }
 
 /* Return -1 if file "name" is defined to be excluded by the specified
- * exclude list, 1 if it is included, and 0 if it was not matched. */
+ * exclude list, 1 if it is included, and 0 if it was not matched.
+ * Sets last_hit_filter_rule to the filter that was hit, or NULL if none. */
 int check_filter(filter_rule_list *listp, enum logcode code,
 		 const char *name, int name_flags)
 {
@@ -1057,10 +1085,12 @@ int check_filter(filter_rule_list *listp, enum logcode code,
 		}
 		if (rule_matches(name, ent, name_flags)) {
 			report_filter_result(code, name, ent, name_flags, listp->debug_type);
+			last_hit_filter_rule = ent;
 			return ent->rflags & FILTRULE_INCLUDE ? 1 : -1;
 		}
 	}
 
+	last_hit_filter_rule = NULL;
 	return 0;
 }
 
@@ -1077,9 +1107,45 @@ static const uchar *rule_strcmp(const uchar *str, const char *rule, int rule_len
 	return NULL;
 }
 
+static char *grab_paren_value(const uchar **s_ptr)
+{
+	const uchar *start, *end;
+	int val_sz;
+	char *val;
+
+	if ((*s_ptr)[1] != '(')
+		return NULL;
+	start = (*s_ptr) + 2;
+
+	for (end = start; *end != ')'; end++)
+		if (!*end || *end == ' ' || *end == '_')
+			return NULL;
+
+	val_sz = end - start + 1;
+	val = new_array(char, val_sz);
+	strlcpy(val, (const char *)start, val_sz);
+	*s_ptr = end; /* remember ++s in parse_rule_tok */
+	return val;
+}
+
+static struct filter_chmod_struct *make_chmod_struct(char *modestr)
+{
+	struct filter_chmod_struct *chmod;
+	struct chmod_mode_struct *modes = NULL;
+
+	if (!parse_chmod(modestr, &modes))
+		return NULL;
+
+	chmod = new(struct filter_chmod_struct);
+	chmod->ref_cnt = 1;
+	chmod->modestr = modestr;
+	chmod->modes = modes;
+	return chmod;
+}
+
 #define FILTRULES_FROM_CONTAINER (FILTRULE_ABS_PATH | FILTRULE_INCLUDE \
 				| FILTRULE_DIRECTORY | FILTRULE_NEGATE \
-				| FILTRULE_PERISHABLE)
+				| FILTRULE_PERISHABLE | FILTRULES_ATTRS)
 
 /* Gets the next include/exclude rule from *rulestr_ptr and advances
  * *rulestr_ptr to point beyond it.  Stores the pattern's start (within
@@ -1094,6 +1160,7 @@ static filter_rule *parse_rule_tok(const char **rulestr_ptr,
 				   const char **pat_ptr, unsigned int *pat_len_ptr)
 {
 	const uchar *s = (const uchar *)*rulestr_ptr;
+	char *val;
 	filter_rule *rule;
 	unsigned int len;
 
@@ -1112,6 +1179,12 @@ static filter_rule *parse_rule_tok(const char **rulestr_ptr,
 	/* Inherit from the template.  Don't inherit FILTRULES_SIDES; we check
 	 * that later. */
 	rule->rflags = template->rflags & FILTRULES_FROM_CONTAINER;
+	if (template->rflags & FILTRULE_CHMOD)
+		rule->chmod = ref_filter_chmod(template->chmod);
+	if (template->rflags & FILTRULE_FORCE_OWNER)
+		rule->force_uid = template->force_uid;
+	if (template->rflags & FILTRULE_FORCE_GROUP)
+		rule->force_gid = template->force_gid;
 
 	/* Figure out what kind of a filter rule "s" is pointing at.  Note
 	 * that if FILTRULE_NO_PREFIXES is set, the rule is either an include
@@ -1258,11 +1331,63 @@ static filter_rule *parse_rule_tok(const char **rulestr_ptr,
 					goto invalid;
 				rule->rflags |= FILTRULE_EXCLUDE_SELF;
 				break;
+			case 'g': {
+				gid_t gid;
+
+				if (!(val = grab_paren_value(&s)))
+					goto invalid;
+				if (group_to_gid(val, &gid, True)) {
+					rule->rflags |= FILTRULE_FORCE_GROUP;
+					rule->force_gid = gid;
+				} else {
+					rprintf(FERROR,
+						"unknown group '%s' in filter rule: %s\n",
+						val, *rulestr_ptr);
+					exit_cleanup(RERR_SYNTAX);
+				}
+				free(val);
+				break;
+			}
+			case 'm': {
+				struct filter_chmod_struct *chmod;
+
+				if (!(val = grab_paren_value(&s)))
+					goto invalid;
+				if ((chmod = make_chmod_struct(val))) {
+					if (rule->rflags & FILTRULE_CHMOD)
+						unref_filter_chmod(rule->chmod);
+					rule->rflags |= FILTRULE_CHMOD;
+					rule->chmod = chmod;
+				} else {
+					rprintf(FERROR,
+						"unparseable chmod string '%s' in filter rule: %s\n",
+						val, *rulestr_ptr);
+					exit_cleanup(RERR_SYNTAX);
+				}
+				break;
+			}
 			case 'n':
 				if (!(rule->rflags & FILTRULE_MERGE_FILE))
 					goto invalid;
 				rule->rflags |= FILTRULE_NO_INHERIT;
 				break;
+			case 'o': {
+				uid_t uid;
+
+				if (!(val = grab_paren_value(&s)))
+					goto invalid;
+				if (user_to_uid(val, &uid, True)) {
+					rule->rflags |= FILTRULE_FORCE_OWNER;
+					rule->force_uid = uid;
+				} else {
+					rprintf(FERROR,
+						"unknown user '%s' in filter rule: %s\n",
+						val, *rulestr_ptr);
+					exit_cleanup(RERR_SYNTAX);
+				}
+				free(val);
+				break;
+			}
 			case 'p':
 				rule->rflags |= FILTRULE_PERISHABLE;
 				break;
@@ -1576,6 +1701,23 @@ char *get_rule_prefix(filter_rule *rule, const char *pat, int for_xfer,
 		else if (am_sender)
 			return NULL;
 	}
+	if (rule->rflags & FILTRULES_ATTRS) {
+		if (!for_xfer || protocol_version >= 31) {
+			if (rule->rflags & FILTRULE_CHMOD)
+				if (!snappendf(&op, (buf + sizeof buf) - op,
+					"m(%s)", rule->chmod->modestr))
+					return NULL;
+			if (rule->rflags & FILTRULE_FORCE_OWNER)
+				if (!snappendf(&op, (buf + sizeof buf) - op,
+					"o(%u)", (unsigned)rule->force_uid))
+					return NULL;
+			if (rule->rflags & FILTRULE_FORCE_GROUP)
+				if (!snappendf(&op, (buf + sizeof buf) - op,
+					"g(%u)", (unsigned)rule->force_gid))
+					return NULL;
+		} else if (!am_sender)
+			return NULL;
+	}
 	if (op - buf > legal_len)
 		return NULL;
 	if (legal_len)
diff --git a/flist.c b/flist.c
--- a/flist.c
+++ b/flist.c
@@ -86,6 +86,7 @@ extern char curr_dir[MAXPATHLEN];
 extern struct chmod_mode_struct *chmod_modes;
 
 extern filter_rule_list filter_list, implied_filter_list, daemon_filter_list;
+extern filter_rule *last_hit_filter_rule;
 
 #ifdef ICONV_OPTION
 extern int filesfrom_convert;
@@ -1259,7 +1260,7 @@ struct file_struct *make_file(const char *fname, struct file_list *flist,
 	} else if (readlink_stat(thisname, &st, linkname) != 0) {
 		int save_errno = errno;
 		/* See if file is excluded before reporting an error. */
-		if (filter_level != NO_FILTERS
+		if (filter_level != NO_FILTERS && filter_level != ALL_FILTERS_NO_EXCLUDE
 		 && (is_excluded(thisname, 0, filter_level)
 		  || is_excluded(thisname, 1, filter_level))) {
 			if (ignore_perishable && save_errno != ENOENT)
@@ -1304,6 +1305,12 @@ struct file_struct *make_file(const char *fname, struct file_list *flist,
 
 	if (filter_level == NO_FILTERS)
 		goto skip_filters;
+	if (filter_level == ALL_FILTERS_NO_EXCLUDE) {
+		/* Call only for the side effect of setting last_hit_filter_rule to
+		 * any operative include filter, which might affect attributes. */
+		is_excluded(thisname, S_ISDIR(st.st_mode) != 0, ALL_FILTERS);
+		goto skip_filters;
+	}
 
 	if (S_ISDIR(st.st_mode)) {
 		if (!xfer_dirs) {
@@ -1536,12 +1543,23 @@ static struct file_struct *send_file_name(int f, struct file_list *flist,
 					  int flags, int filter_level)
 {
 	struct file_struct *file;
+	BOOL can_tweak_mode;
 
 	file = make_file(fname, flist, stp, flags, filter_level);
 	if (!file)
 		return NULL;
 
-	if (chmod_modes && !S_ISLNK(file->mode) && file->mode)
+	can_tweak_mode = !S_ISLNK(file->mode) && file->mode;
+	if ((filter_level == ALL_FILTERS || filter_level == ALL_FILTERS_NO_EXCLUDE)
+		&& last_hit_filter_rule) {
+		if ((last_hit_filter_rule->rflags & FILTRULE_CHMOD) && can_tweak_mode)
+			file->mode = tweak_mode(file->mode, last_hit_filter_rule->chmod->modes);
+		if ((last_hit_filter_rule->rflags & FILTRULE_FORCE_OWNER) && uid_ndx)
+			F_OWNER(file) = last_hit_filter_rule->force_uid;
+		if ((last_hit_filter_rule->rflags & FILTRULE_FORCE_GROUP) && gid_ndx)
+			F_GROUP(file) = last_hit_filter_rule->force_gid;
+	}
+	if (chmod_modes && can_tweak_mode)
 		file->mode = tweak_mode(file->mode, chmod_modes);
 
 	if (f >= 0) {
@@ -2443,7 +2461,7 @@ struct file_list *send_file_list(int f, int argc, char *argv[])
 			struct file_struct *file;
 			file = send_file_name(f, flist, fbuf, &st,
 					      FLAG_TOP_DIR | FLAG_CONTENT_DIR | flags,
-					      NO_FILTERS);
+					      ALL_FILTERS_NO_EXCLUDE);
 			if (!file)
 				continue;
 			if (inc_recurse) {
@@ -2457,7 +2475,7 @@ struct file_list *send_file_list(int f, int argc, char *argv[])
 			} else
 				send_if_directory(f, flist, file, fbuf, len, flags);
 		} else
-			send_file_name(f, flist, fbuf, &st, flags, NO_FILTERS);
+			send_file_name(f, flist, fbuf, &st, flags, ALL_FILTERS_NO_EXCLUDE);
 	}
 
 	if (reenable_multiplex >= 0)
diff --git a/rsync.1.md b/rsync.1.md
--- a/rsync.1.md
+++ b/rsync.1.md
@@ -1513,7 +1513,9 @@ expand it.
     >     --chmod=D2775,F664
 
     It is also legal to specify multiple `--chmod` options, as each additional
-    option is just appended to the list of changes to make.
+    option is just appended to the list of changes to make.  To change
+    permissions of files matching a pattern, use an include filter with the `m`
+    modifier, which takes effect before any `--chmod` options.
 
     See the [`--perms`](#opt) and [`--executability`](#opt) options for how the
     resulting permission value can be applied to the files in the transfer.
@@ -3033,6 +3035,10 @@ expand it.
     An older rsync client may need to use [`-s`](#opt) to avoid a complaint
     about wildcard characters, but a modern rsync handles this automatically.
 
+    To change ownership of files matching a pattern, use an include filter with
+    a `o` or `g` modifier, which take effect before uid/gid mapping and
+    therefore *can* be mixed with [`--usermap` & `--groupmap`](#opt--usermap).
+
 0.  `--timeout=SECONDS`
 
     This option allows you to set a maximum I/O timeout in seconds.  If no data
@@ -4187,6 +4193,15 @@ The following modifiers are accepted after an include (+) or exclude (-) rule:
   like "CVS" and "`*.o`" are marked as perishable, and will not prevent a
   directory that was removed on the source from being deleted on the
   destination.
+- An `m(CHMOD)` on an include rule tweaks the permissions of matching source
+  files in the same way as [`--chmod`](#opt).  This happens before any tweaks
+  requested via [`--chmod`](#opt).
+- An `o(USER)` on an include rule pretends that matching source files are owned
+  by `USER` (a name or numeric uid).  This happens before any uid mapping by
+  name or [`--usermap`](#opt).
+- A `g(GROUP)` on an include rule pretends that matching source files are owned
+  by `GROUP` (a name or numeric gid).  This happens before any gid mapping by
+  name or [`--groupmap`](#opt--usermap).
 - An `x` indicates that a rule affects xattr names in xattr copy/delete
   operations (and is thus ignored when matching file/dir names).  If no
   xattr-matching rules are specified, a default xattr filtering rule is used
@@ -4244,6 +4259,12 @@ The following modifiers are accepted after a merge or dir-merge rule:
   rules in the file must not specify sides (via a modifier or a rule prefix
   such as `hide`).
 
+The attribute-affecting modifiers `m`, `o`, and `g` work only in client filters
+(not in daemon filters), and only the modifiers of the first matching rule are
+applied.  As an example, assuming [`--super`](#opt) is enabled, the rule
+"`+o(root),g(root),m(go=) *~`" would ensure that all "backup"
+files belong to root and are not accessible to anyone else.
+
 Per-directory rules are inherited in all subdirectories of the directory where
 the merge-file was found unless the 'n' modifier was used.  Each subdirectory's
 rules are prefixed to the inherited per-directory rules from its parents, which
diff --git a/rsync.h b/rsync.h
--- a/rsync.h
+++ b/rsync.h
@@ -182,6 +182,9 @@
 #define NO_FILTERS	0
 #define SERVER_FILTERS	1
 #define ALL_FILTERS	2
+/* Don't let the file be excluded, but check for a filter that might affect
+ * its attributes via FILTRULES_ATTRS. */
+#define ALL_FILTERS_NO_EXCLUDE	3
 
 #define XFLG_FATAL_ERRORS	(1<<0)
 #define XFLG_OLD_PREFIXES	(1<<1)
@@ -983,6 +986,8 @@ struct map_struct {
 	int status;		/* first errno from read errors		*/
 };
 
+struct chmod_mode_struct;
+
 #define sum2_at(s, i)	((s)->sum2_array + ((size_t)(i) * xfer_sum_len))
 
 #define NAME_IS_FILE		(0)    /* filter name as a file */
@@ -1010,8 +1015,18 @@ struct map_struct {
 #define FILTRULE_CLEAR_LIST	(1<<18)/* this item is the "!" token */
 #define FILTRULE_PERISHABLE	(1<<19)/* perishable if parent dir goes away */
 #define FILTRULE_XATTR		(1<<20)/* rule only applies to xattr names */
+#define FILTRULE_CHMOD		(1<<21)/* chmod-tweak matching files */
+#define FILTRULE_FORCE_OWNER	(1<<22)/* force owner of matching files */
+#define FILTRULE_FORCE_GROUP	(1<<23)/* force group of matching files */
 
 #define FILTRULES_SIDES (FILTRULE_SENDER_SIDE | FILTRULE_RECEIVER_SIDE)
+#define FILTRULES_ATTRS (FILTRULE_CHMOD | FILTRULE_FORCE_OWNER | FILTRULE_FORCE_GROUP)
+
+struct filter_chmod_struct {
+	unsigned int ref_cnt;
+	char *modestr;
+	struct chmod_mode_struct *modes;
+};
 
 typedef struct filter_struct {
 	struct filter_struct *next;
@@ -1021,6 +1036,11 @@ typedef struct filter_struct {
 		int slash_cnt;
 		struct filter_list_struct *mergelist;
 	} u;
+	/* TODO: Use an "extras" mechanism to avoid
+	 * allocating this memory when we don't need it. */
+	struct filter_chmod_struct *chmod;
+	uid_t force_uid;
+	gid_t force_gid;
 	uchar elide;
 } filter_rule;
 
diff --git a/util1.c b/util1.c
--- a/util1.c
+++ b/util1.c
@@ -918,6 +918,25 @@ size_t stringjoin(char *dest, size_t destsize, ...)
 	return ret;
 }
 
+/* Append formatted text at *dest_ptr up to a maximum of sz (like snprintf).
+ * On success, advance *dest_ptr and return True; on overflow, return False. */
+BOOL snappendf(char **dest_ptr, size_t sz, const char *format, ...)
+{
+	va_list ap;
+	size_t len;
+
+	va_start(ap, format);
+	len = vsnprintf(*dest_ptr, sz, format, ap);
+	va_end(ap);
+
+	if (len >= sz)
+		return False;
+	else {
+		*dest_ptr += len;
+		return True;
+	}
+}
+
 int count_dir_elements(const char *p)
 {
 	int cnt = 0, new_component = 1;
diff -Nurp a/rrsync.1 b/rrsync.1
--- a/rrsync.1
+++ b/rrsync.1
@@ -1,176 +0,0 @@
-.TH "rrsync" "1" "15 Jan 2025" "rrsync from rsync 3.4.1" "User Commands"
-.\" prefix=/usr
-.P
-.SH "NAME"
-.P
-rrsync \- a script to setup restricted rsync users via ssh logins
-.P
-.SH "SYNOPSIS"
-.P
-.nf
-rrsync [-ro|-wo] [-munge] [-no-del] [-no-lock] [-no-overwrite]  DIR
-.fi
-.P
-The single non-option argument specifies the restricted \fIDIR\fP to use. It can be
-relative to the user's home directory or an absolute path.
-.P
-The online version of this manpage (that includes cross-linking of topics)
-is available at
-.UR https://download.samba.org/pub/rsync/rrsync.1
-.UE .
-.P
-.SH "DESCRIPTION"
-.P
-A user's ssh login can be restricted to only allow the running of an rsync
-transfer in one of two easy ways:
-.P
-.IP o
-forcing the running of the rrsync script
-.IP o
-forcing the running of an rsync daemon-over-ssh command.
-.P
-Both of these setups use a feature of ssh that allows a command to be forced to
-run instead of an interactive shell.  However, if the user's home shell is bash,
-please see BASH SECURITY ISSUE for a potential issue.
-.P
-To use the rrsync script, edit the user's \fB~/.ssh/authorized_keys\fP file and add
-a prefix like one of the following (followed by a space) in front of each
-ssh-key line that should be restricted:
-.RS 4
-.P
-.nf
-command="rrsync DIR"
-command="rrsync -ro DIR"
-command="rrsync -munge -no-del DIR"
-.fi
-.RE
-.P
-Then, ensure that the rrsync script has your desired option restrictions. You
-may want to copy the script to a local bin dir with a unique name if you want
-to have multiple configurations. One or more rrsync options can be specified
-prior to the \fIDIR\fP if you want to further restrict the transfer.
-.P
-To use an rsync daemon setup, edit the user's \fB~/.ssh/authorized_keys\fP file and
-add a prefix like one of the following (followed by a space) in front of each
-ssh-key line that should be restricted:
-.RS 4
-.P
-.nf
-command="rsync --server --daemon ."
-command="rsync --server --daemon --config=/PATH/TO/rsyncd.conf ."
-.fi
-.RE
-.P
-Then, ensure that the rsyncd.conf file is created with one or more module names
-with the appropriate path and option restrictions.  If rsync's
-\fB\-\-config\fP option is omitted, it defaults to \fB~/rsyncd.conf\fP.
-See the \fBrsyncd.conf\fP(5) manpage for details of how to
-configure an rsync daemon.
-.P
-When using rrsync, there can be just one restricted dir per authorized key.  A
-daemon setup, on the other hand, allows multiple module names inside the config
-file, each one with its own path setting.
-.P
-The remainder of this manpage is dedicated to using the rrsync script.
-.P
-.SH "OPTIONS"
-.P
-.IP "\fB\-ro\fP"
-Allow only reading from the DIR. Implies \fB\-no-del\fP and
-\fB\-no-lock\fP.
-.IP "\fB\-wo\fP"
-Allow only writing to the DIR.
-.IP "\fB\-munge\fP"
-Enable rsync's \fB\-\-munge-links\fP on the server side.
-.IP "\fB\-no-del\fP"
-Disable rsync's \fB\-\-delete*\fP and \fB\-\-remove*\fP options.
-.IP "\fB\-no-lock\fP"
-Avoid the single-run (per-user) lock check.  Useful with \fB\-munge\fP.
-.IP "\fB\-no-overwrite\fP"
-Enforce \fB\-\-ignore-existing\fP on the server. Prevents overwriting existing
-files when the server is the receiver.
-.IP "\fB\-help\fP, \fB\-h\fP"
-Output this help message and exit.
-.P
-.SH "SECURITY RESTRICTIONS"
-.P
-The rrsync script validates the path arguments it is sent to try to restrict
-them to staying within the specified DIR.
-.P
-The rrsync script rejects rsync's \fB\-\-copy-links\fP option (by
-default) so that a copy cannot dereference a symlink within the DIR to get to a
-file outside the DIR.
-.P
-The rrsync script rejects rsync's \fB\-\-protect-args\fP (\fB\-s\fP) option
-because it would allow options to be sent to the server-side that the script
-cannot check.  If you want to support \fB\-\-protect-args\fP, use a daemon-over-ssh
-setup.
-.P
-The rrsync script accepts just a subset of rsync's options that the real rsync
-uses when running the server command.  A few extra convenience options are also
-included to help it to interact with BackupPC and accept some convenient user
-overrides.
-.P
-The script (or a copy of it) can be manually edited if you want it to customize
-the option handling.
-.P
-.SH "BASH SECURITY ISSUE"
-.P
-If your users have bash set as their home shell, bash may try to be overly
-helpful and ensure that the user's login bashrc files are run prior to
-executing the forced command.  This can be a problem if the user can somehow
-update their home bashrc files, perhaps via the restricted copy, a shared home
-directory, or something similar.
-.P
-One simple way to avoid the issue is to switch the user to a simpler shell,
-such as dash.  When choosing the new home shell, make sure that you're not
-choosing bash in disguise, as it is unclear if it avoids the security issue.
-.P
-Another potential fix is to ensure that the user's home directory is not a
-shared mount and that they have no means of copying files outside of their
-restricted directories.  This may require you to force the enabling of symlink
-munging on the server side.
-.P
-A future version of openssh may have a change to the handling of forced
-commands that allows it to avoid using the user's home shell.
-.P
-.SH "EXAMPLES"
-.P
-The \fB~/.ssh/authorized_keys\fP file might have lines in it like this:
-.RS 4
-.P
-.nf
-command="rrsync client/logs" ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAIEAzG...
-command="rrsync -ro results" ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAIEAmk...
-.fi
-.RE
-.P
-.SH "FILES"
-.P
-~/.ssh/authorized_keys
-.P
-.SH "SEE ALSO"
-.P
-\fBrsync\fP(1), \fBrsyncd.conf\fP(5)
-.P
-.SH "VERSION"
-.P
-This manpage is current for version 3.4.1 of rsync.
-.P
-.SH "CREDITS"
-.P
-rsync is distributed under the GNU General Public License.  See the file
-COPYING for details.
-.P
-An rsync web site is available at
-.UR https://rsync.samba.org/
-.UE
-and its github
-project is
-.UR https://github.com/RsyncProject/rsync
-.UE .
-.P
-.SH "AUTHOR"
-.P
-The original rrsync perl script was written by Joe Smith.  Many people have
-later contributed to it.  The python version was created by Wayne Davison.
diff -Nurp a/rrsync.1.html b/rrsync.1.html
--- a/rrsync.1.html
+++ b/rrsync.1.html
@@ -1,169 +0,0 @@
-<html><head>
-<title>rrsync(1) manpage</title>
-<meta charset="UTF-8"/>
-<link href="https://fonts.googleapis.com/css2?family=Roboto&family=Roboto+Mono&display=swap" rel="stylesheet">
-<style>
-body {
-  max-width: 50em;
-  margin: auto;
-}
-body, b, strong, u {
-  font-family: 'Roboto', sans-serif;
-}
-a.tgt { font-face: symbol; font-weight: 400; font-size: 70%; visibility: hidden; text-decoration: none; color: #ddd; padding: 0 4px; border: 0; }
-a.tgt:after { content: 'ðŸ”—'; }
-a.tgt:hover { color: #444; background-color: #eaeaea; }
-h1:hover > a.tgt, h2:hover > a.tgt, h3:hover > a.tgt, dt:hover > a.tgt { visibility: visible; }
-code {
-  font-family: 'Roboto Mono', monospace;
-  font-weight: bold;
-  white-space: pre;
-}
-pre code {
-  display: block;
-  font-weight: normal;
-}
-blockquote pre code {
-  background: #f1f1f1;
-}
-dd p:first-of-type {
-  margin-block-start: 0em;
-}
-</style>
-</head><body>
-<h2 id="NAME">NAME<a href="#NAME" class="tgt"></a></h2>
-<p>rrsync -&#8288; a script to setup restricted rsync users via ssh logins</p>
-<h2 id="SYNOPSIS">SYNOPSIS<a href="#SYNOPSIS" class="tgt"></a></h2>
-<pre><code>rrsync [-ro|-wo] [-munge] [-no-del] [-no-lock] [-no-overwrite]  DIR
-</code></pre>
-<p>The single non-option argument specifies the restricted <u>DIR</u> to use. It can be
-relative to the user's home directory or an absolute path.</p>
-<p>The online version of this manpage (that includes cross-linking of topics)
-is available at <a href="https://download.samba.org/pub/rsync/rrsync.1">https://download.samba.org/pub/rsync/rrsync.1</a>.</p>
-<h2 id="DESCRIPTION">DESCRIPTION<a href="#DESCRIPTION" class="tgt"></a></h2>
-<p>A user's ssh login can be restricted to only allow the running of an rsync
-transfer in one of two easy ways:</p>
-<ul>
-<li>forcing the running of the rrsync script</li>
-<li>forcing the running of an rsync daemon-over-ssh command.</li>
-</ul>
-<p>Both of these setups use a feature of ssh that allows a command to be forced to
-run instead of an interactive shell.  However, if the user's home shell is bash,
-please see <a href="#BASH_SECURITY_ISSUE">BASH SECURITY ISSUE</a> for a potential issue.</p>
-<p>To use the rrsync script, edit the user's <code>~/.ssh/authorized_keys</code> file and add
-a prefix like one of the following (followed by a space) in front of each
-ssh-key line that should be restricted:</p>
-<blockquote>
-<pre><code>command=&quot;rrsync DIR&quot;
-command=&quot;rrsync -ro DIR&quot;
-command=&quot;rrsync -munge -no-del DIR&quot;
-</code></pre>
-</blockquote>
-<p>Then, ensure that the rrsync script has your desired option restrictions. You
-may want to copy the script to a local bin dir with a unique name if you want
-to have multiple configurations. One or more rrsync options can be specified
-prior to the <u>DIR</u> if you want to further restrict the transfer.</p>
-<p>To use an rsync daemon setup, edit the user's <code>~/.ssh/authorized_keys</code> file and
-add a prefix like one of the following (followed by a space) in front of each
-ssh-key line that should be restricted:</p>
-<blockquote>
-<pre><code>command=&quot;rsync --server --daemon .&quot;
-command=&quot;rsync --server --daemon --config=/PATH/TO/rsyncd.conf .&quot;
-</code></pre>
-</blockquote>
-<p>Then, ensure that the rsyncd.conf file is created with one or more module names
-with the appropriate path and option restrictions.  If rsync's
-<a href="rsync.1#dopt--config"><code>--config</code></a> option is omitted, it defaults to <code>~/rsyncd.conf</code>.
-See the <a href="rsyncd.conf.5"><strong>rsyncd.conf</strong>(5)</a> manpage for details of how to
-configure an rsync daemon.</p>
-<p>When using rrsync, there can be just one restricted dir per authorized key.  A
-daemon setup, on the other hand, allows multiple module names inside the config
-file, each one with its own path setting.</p>
-<p>The remainder of this manpage is dedicated to using the rrsync script.</p>
-<h2 id="OPTIONS">OPTIONS<a href="#OPTIONS" class="tgt"></a></h2>
-<dl>
-
-<dt id="opt-ro"><code>-ro</code><a href="#opt-ro" class="tgt"></a></dt><dd>
-<p>Allow only reading from the DIR. Implies <a href="#opt-no-del"><code>-no-del</code></a> and
-<a href="#opt-no-lock"><code>-no-lock</code></a>.</p>
-</dd>
-
-<dt id="opt-wo"><code>-wo</code><a href="#opt-wo" class="tgt"></a></dt><dd>
-<p>Allow only writing to the DIR.</p>
-</dd>
-
-<dt id="opt-munge"><code>-munge</code><a href="#opt-munge" class="tgt"></a></dt><dd>
-<p>Enable rsync's <a href="rsync.1#opt--munge-links"><code>--munge-links</code></a> on the server side.</p>
-</dd>
-
-<dt id="opt-no-del"><code>-no-del</code><a href="#opt-no-del" class="tgt"></a></dt><dd>
-<p>Disable rsync's <code>--delete*</code> and <code>--remove*</code> options.</p>
-</dd>
-
-<dt id="opt-no-lock"><code>-no-lock</code><a href="#opt-no-lock" class="tgt"></a></dt><dd>
-<p>Avoid the single-run (per-user) lock check.  Useful with <a href="#opt-munge"><code>-munge</code></a>.</p>
-</dd>
-
-<dt id="opt-no-overwrite"><code>-no-overwrite</code><a href="#opt-no-overwrite" class="tgt"></a></dt><dd>
-<p>Enforce <code>--ignore-existing</code> on the server. Prevents overwriting existing
-files when the server is the receiver.</p>
-</dd>
-
-<span id="opt-h"></span><dt id="opt-help"><code>-help</code>, <code>-h</code><a href="#opt-help" class="tgt"></a></dt><dd>
-<p>Output this help message and exit.</p>
-</dd>
-</dl>
-<h2 id="SECURITY_RESTRICTIONS">SECURITY RESTRICTIONS<a href="#SECURITY_RESTRICTIONS" class="tgt"></a></h2>
-<p>The rrsync script validates the path arguments it is sent to try to restrict
-them to staying within the specified DIR.</p>
-<p>The rrsync script rejects rsync's <a href="rsync.1#opt--copy-links"><code>--copy-links</code></a> option (by
-default) so that a copy cannot dereference a symlink within the DIR to get to a
-file outside the DIR.</p>
-<p>The rrsync script rejects rsync's <a href="rsync.1#opt--protect-args"><code>--protect-args</code></a> (<code>-s</code>) option
-because it would allow options to be sent to the server-side that the script
-cannot check.  If you want to support <code>--protect-args</code>, use a daemon-over-ssh
-setup.</p>
-<p>The rrsync script accepts just a subset of rsync's options that the real rsync
-uses when running the server command.  A few extra convenience options are also
-included to help it to interact with BackupPC and accept some convenient user
-overrides.</p>
-<p>The script (or a copy of it) can be manually edited if you want it to customize
-the option handling.</p>
-<h2 id="BASH_SECURITY_ISSUE">BASH SECURITY ISSUE<a href="#BASH_SECURITY_ISSUE" class="tgt"></a></h2>
-<p>If your users have bash set as their home shell, bash may try to be overly
-helpful and ensure that the user's login bashrc files are run prior to
-executing the forced command.  This can be a problem if the user can somehow
-update their home bashrc files, perhaps via the restricted copy, a shared home
-directory, or something similar.</p>
-<p>One simple way to avoid the issue is to switch the user to a simpler shell,
-such as dash.  When choosing the new home shell, make sure that you're not
-choosing bash in disguise, as it is unclear if it avoids the security issue.</p>
-<p>Another potential fix is to ensure that the user's home directory is not a
-shared mount and that they have no means of copying files outside of their
-restricted directories.  This may require you to force the enabling of symlink
-munging on the server side.</p>
-<p>A future version of openssh may have a change to the handling of forced
-commands that allows it to avoid using the user's home shell.</p>
-<h2 id="EXAMPLES">EXAMPLES<a href="#EXAMPLES" class="tgt"></a></h2>
-<p>The <code>~/.ssh/authorized_keys</code> file might have lines in it like this:</p>
-<blockquote>
-<pre><code>command=&quot;rrsync client/logs&quot; ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAIEAzG...
-command=&quot;rrsync -ro results&quot; ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAIEAmk...
-</code></pre>
-</blockquote>
-<h2 id="FILES">FILES<a href="#FILES" class="tgt"></a></h2>
-<p>~/.ssh/authorized_keys</p>
-<h2 id="SEE_ALSO">SEE ALSO<a href="#SEE_ALSO" class="tgt"></a></h2>
-<p><a href="rsync.1"><strong>rsync</strong>(1)</a>, <a href="rsyncd.conf.5"><strong>rsyncd.conf</strong>(5)</a></p>
-<h2 id="VERSION">VERSION<a href="#VERSION" class="tgt"></a></h2>
-<p>This manpage is current for version 3.4.1 of rsync.</p>
-<h2 id="CREDITS">CREDITS<a href="#CREDITS" class="tgt"></a></h2>
-<p>rsync is distributed under the GNU General Public License.  See the file
-<a href="COPYING">COPYING</a> for details.</p>
-<p>An rsync web site is available at <a href="https://rsync.samba.org/">https://rsync.samba.org/</a> and its github
-project is <a href="https://github.com/RsyncProject/rsync">https://github.com/RsyncProject/rsync</a>.</p>
-<h2 id="AUTHOR">AUTHOR<a href="#AUTHOR" class="tgt"></a></h2>
-<p>The original rrsync perl script was written by Joe Smith.  Many people have
-later contributed to it.  The python version was created by Wayne Davison.</p>
-<div style="float: right"><p><i>15 Jan 2025</i></p></div>
-</body></html>
diff -Nurp a/rsync.1 b/rsync.1
--- a/rsync.1
+++ b/rsync.1
@@ -1,5 +1,5 @@
 .TH "rsync" "1" "15 Jan 2025" "rsync 3.4.1" "User Commands"
-.\" prefix=/usr
+.\" prefix=/usr/local
 .P
 .SH "NAME"
 .P
@@ -1629,7 +1629,9 @@ Using octal mode numbers is also allowed
 .RE
 .IP
 It is also legal to specify multiple \fB\-\-chmod\fP options, as each additional
-option is just appended to the list of changes to make.
+option is just appended to the list of changes to make.  To change
+permissions of files matching a pattern, use an include filter with the \fBm\fP
+modifier, which takes effect before any \fB\-\-chmod\fP options.
 .IP
 See the \fB\-\-perms\fP and \fB\-\-executability\fP options for how the
 resulting permission value can be applied to the files in the transfer.
@@ -3108,6 +3110,10 @@ implied \fB\-\-owner\fP and/or \fB\-\-gr
 .IP
 An older rsync client may need to use \fB\-s\fP to avoid a complaint
 about wildcard characters, but a modern rsync handles this automatically.
+.IP
+To change ownership of files matching a pattern, use an include filter with
+a \fBo\fP or \fBg\fP modifier, which take effect before uid/gid mapping and
+therefore \fIcan\fP be mixed with \fB\-\-usermap\fP & \fB\-\-groupmap\fP.
 .IP "\fB\-\-timeout=SECONDS\fP"
 This option allows you to set a maximum I/O timeout in seconds.  If no data
 is transferred for the specified time then rsync will exit.  The default is
@@ -4331,6 +4337,18 @@ like "CVS" and "\fB*.o\fP" are marked as
 directory that was removed on the source from being deleted on the
 destination.
 .IP o
+An \fBm(CHMOD)\fP on an include rule tweaks the permissions of matching source
+files in the same way as \fB\-\-chmod\fP.  This happens before any tweaks
+requested via \fB\-\-chmod\fP.
+.IP o
+An \fBo(USER)\fP on an include rule pretends that matching source files are owned
+by \fBUSER\fP (a name or numeric uid).  This happens before any uid mapping by
+name or \fB\-\-usermap\fP.
+.IP o
+A \fBg(GROUP)\fP on an include rule pretends that matching source files are owned
+by \fBGROUP\fP (a name or numeric gid).  This happens before any gid mapping by
+name or \fB\-\-groupmap\fP.
+.IP o
 An \fBx\fP indicates that a rule affects xattr names in xattr copy/delete
 operations (and is thus ignored when matching file/dir names).  If no
 xattr-matching rules are specified, a default xattr filtering rule is used
@@ -4399,6 +4417,12 @@ specifies sides to affect (via the \fBs\
 rules in the file must not specify sides (via a modifier or a rule prefix
 such as \fBhide\fP).
 .P
+The attribute-affecting modifiers \fBm\fP, \fBo\fP, and \fBg\fP work only in client filters
+(not in daemon filters), and only the modifiers of the first matching rule are
+applied.  As an example, assuming \fB\-\-super\fP is enabled, the rule
+"\fB+o(root),g(root),m(go=)\ *~\fP" would ensure that all "backup"
+files belong to root and are not accessible to anyone else.
+.P
 Per-directory rules are inherited in all subdirectories of the directory where
 the merge-file was found unless the 'n' modifier was used.  Each subdirectory's
 rules are prefixed to the inherited per-directory rules from its parents, which
diff -Nurp a/rsync.1.html b/rsync.1.html
--- a/rsync.1.html
+++ b/rsync.1.html
@@ -1444,7 +1444,9 @@ consistent executability across all bits
 </code></pre>
 </blockquote>
 <p>It is also legal to specify multiple <code>--chmod</code> options, as each additional
-option is just appended to the list of changes to make.</p>
+option is just appended to the list of changes to make.  To change
+permissions of files matching a pattern, use an include filter with the <code>m</code>
+modifier, which takes effect before any <code>--chmod</code> options.</p>
 <p>See the <a href="#opt--perms"><code>--perms</code></a> and <a href="#opt--executability"><code>--executability</code></a> options for how the
 resulting permission value can be applied to the files in the transfer.</p>
 </dd>
@@ -2832,6 +2834,9 @@ be omitted, but if USER is empty, a lead
 implied <a href="#opt--owner"><code>--owner</code></a> and/or <a href="#opt--group"><code>--group</code></a> options).</p>
 <p>An older rsync client may need to use <a href="#opt-s"><code>-s</code></a> to avoid a complaint
 about wildcard characters, but a modern rsync handles this automatically.</p>
+<p>To change ownership of files matching a pattern, use an include filter with
+a <code>o</code> or <code>g</code> modifier, which take effect before uid/gid mapping and
+therefore <u>can</u> be mixed with <a href="#opt--usermap"><code>--usermap</code> &amp; <code>--groupmap</code></a>.</p>
 </dd>
 
 <dt id="opt--timeout"><code>--timeout=SECONDS</code><a href="#opt--timeout" class="tgt"></a></dt><dd>
@@ -3913,6 +3918,15 @@ directories that are being deleted.  For
 like &quot;CVS&quot; and &quot;<code>*.o</code>&quot; are marked as perishable, and will not prevent a
 directory that was removed on the source from being deleted on the
 destination.</li>
+<li>An <code>m(CHMOD)</code> on an include rule tweaks the permissions of matching source
+files in the same way as <a href="#opt--chmod"><code>--chmod</code></a>.  This happens before any tweaks
+requested via <a href="#opt--chmod"><code>--chmod</code></a>.</li>
+<li>An <code>o(USER)</code> on an include rule pretends that matching source files are owned
+by <code>USER</code> (a name or numeric uid).  This happens before any uid mapping by
+name or <a href="#opt--usermap"><code>--usermap</code></a>.</li>
+<li>A <code>g(GROUP)</code> on an include rule pretends that matching source files are owned
+by <code>GROUP</code> (a name or numeric gid).  This happens before any gid mapping by
+name or <a href="#opt--usermap"><code>--groupmap</code></a>.</li>
 <li>An <code>x</code> indicates that a rule affects xattr names in xattr copy/delete
 operations (and is thus ignored when matching file/dir names).  If no
 xattr-matching rules are specified, a default xattr filtering rule is used
@@ -3968,6 +3982,11 @@ specifies sides to affect (via the <code
 rules in the file must not specify sides (via a modifier or a rule prefix
 such as <code>hide</code>).</li>
 </ul>
+<p>The attribute-affecting modifiers <code>m</code>, <code>o</code>, and <code>g</code> work only in client filters
+(not in daemon filters), and only the modifiers of the first matching rule are
+applied.  As an example, assuming <a href="#opt--super"><code>--super</code></a> is enabled, the rule
+&quot;<code>+o(root),g(root),m(go=) *~</code>&quot; would ensure that all &quot;backup&quot;
+files belong to root and are not accessible to anyone else.</p>
 <p>Per-directory rules are inherited in all subdirectories of the directory where
 the merge-file was found unless the 'n' modifier was used.  Each subdirectory's
 rules are prefixed to the inherited per-directory rules from its parents, which
diff -Nurp a/rsyncd.conf.5 b/rsyncd.conf.5
--- a/rsyncd.conf.5
+++ b/rsyncd.conf.5
@@ -1,5 +1,5 @@
 .TH "rsyncd.conf" "5" "15 Jan 2025" "rsyncd.conf from rsync 3.4.1" "User Commands"
-.\" prefix=/usr
+.\" prefix=/usr/local
 .P
 .SH "NAME"
 .P
@@ -73,11 +73,11 @@ and a single line something like this to
 .RS 4
 .P
 .nf
-rsync   stream  tcp     nowait  root   /usr/bin/rsync rsyncd --daemon
+rsync   stream  tcp     nowait  root   /usr/local/bin/rsync rsyncd --daemon
 .fi
 .RE
 .P
-Replace "/usr/bin/rsync" with the path to where you have rsync installed on
+Replace "/usr/local/bin/rsync" with the path to where you have rsync installed on
 your system.  You will then need to send inetd a HUP signal to tell it to
 reread its config file.
 .P
diff -Nurp a/rsyncd.conf.5.html b/rsyncd.conf.5.html
--- a/rsyncd.conf.5.html
+++ b/rsyncd.conf.5.html
@@ -77,10 +77,10 @@ command &quot;<code>rsync --daemon</code
 </blockquote>
 <p>and a single line something like this to /etc/inetd.conf:</p>
 <blockquote>
-<pre><code>rsync   stream  tcp     nowait  root   /usr/bin/rsync rsyncd --daemon
+<pre><code>rsync   stream  tcp     nowait  root   /usr/local/bin/rsync rsyncd --daemon
 </code></pre>
 </blockquote>
-<p>Replace &quot;/usr/bin/rsync&quot; with the path to where you have rsync installed on
+<p>Replace &quot;/usr/local/bin/rsync&quot; with the path to where you have rsync installed on
 your system.  You will then need to send inetd a HUP signal to tell it to
 reread its config file.</p>
 <p>Note that you should <strong>not</strong> send the rsync daemon a HUP signal to force it to
diff -Nurp a/rsync-ssl.1 b/rsync-ssl.1
--- a/rsync-ssl.1
+++ b/rsync-ssl.1
@@ -1,5 +1,5 @@
 .TH "rsync-ssl" "1" "15 Jan 2025" "rsync-ssl from rsync 3.4.1" "User Commands"
-.\" prefix=/usr
+.\" prefix=/usr/local
 .P
 .SH "NAME"
 .P
