This adds Service Location Protocol support.

To use this patch, run these commands for a successful build:

    patch -p1 <patches/slp.diff
    ./prepare-source
    ./configure --enable-slp
    make

TODO: the configure changes should abort if the user requests --enable-slp
and we can't honor that request.

based-on: 3305a7a063ab0167cab5bf7029da53abaa9fdb6e
diff --git a/Makefile.in b/Makefile.in
--- a/Makefile.in
+++ b/Makefile.in
@@ -17,6 +17,8 @@ CXX=@CXX@
 CXXFLAGS=@CXXFLAGS@
 EXEEXT=@EXEEXT@
 LDFLAGS=@LDFLAGS@
+LIBSLP=@LIBSLP@
+SLPOBJ=@SLPOBJ@
 LIBOBJDIR=lib/
 
 INSTALLCMD=@INSTALL@
@@ -48,7 +50,7 @@ OBJS1=flist.o rsync.o generator.o receiver.o cleanup.o sender.o exclude.o \
 OBJS2=options.o io.o compat.o hlink.o token.o uidlist.o socket.o hashtable.o \
 	usage.o fileio.o batch.o clientname.o chmod.o acls.o xattrs.o
 OBJS3=progress.o pipe.o @MD5_ASM@ @ROLL_SIMD@ @ROLL_ASM@
-DAEMON_OBJ = params.o loadparm.o clientserver.o access.o connection.o authenticate.o
+DAEMON_OBJ = params.o loadparm.o clientserver.o access.o connection.o authenticate.o $(SLPOBJ)
 popt_OBJS=popt/findme.o  popt/popt.o  popt/poptconfig.o \
 	popt/popthelp.o popt/poptparse.o popt/poptint.o
 OBJS=$(OBJS1) $(OBJS2) $(OBJS3) $(DAEMON_OBJ) $(LIBOBJ) @BUILD_ZLIB@ @BUILD_POPT@
@@ -103,7 +105,7 @@ install-strip:
 	$(MAKE) INSTALL_STRIP='-s' install
 
 rsync$(EXEEXT): $(OBJS)
-	$(CC) $(CFLAGS) $(LDFLAGS) -o $@ $(OBJS) $(LIBS)
+	$(CC) $(CFLAGS) $(LDFLAGS) -o $@ $(OBJS) $(LIBS) $(LIBSLP)
 
 rrsync: support/rrsync
 	cp -p $(srcdir)/support/rrsync rrsync
diff --git a/clientserver.c b/clientserver.c
--- a/clientserver.c
+++ b/clientserver.c
@@ -1533,6 +1533,13 @@ int daemon_main(void)
 	 * address too.  In fact, why not just do getnameinfo on the
 	 * local address??? */
 
+#ifdef HAVE_LIBSLP
+	if (lp_use_slp() && register_services()) {
+		rprintf(FINFO,
+		    "Couldn't register with service discovery protocol, continuing anyway\n");
+	}
+#endif
+
 	start_accept_loop(rsync_port, start_daemon);
 	return -1;
 }
diff --git a/configure.ac b/configure.ac
--- a/configure.ac
+++ b/configure.ac
@@ -1067,6 +1067,29 @@ if test $rsync_cv_can_hardlink_special = yes; then
     AC_DEFINE(CAN_HARDLINK_SPECIAL, 1, [Define to 1 if link() can hard-link special files.])
 fi
 
+AC_ARG_ENABLE(slp, [  --disable-slp           turn off SLP support, defaults to on])
+AC_ARG_WITH(openslp-libs, [  --with-openslp-libs     set directory for OpenSLP library],
+    LDFLAGS="-L$withval $LDFLAGS"
+    DSOFLAGS="-L$withval $DSOFLAGS",)
+AC_ARG_WITH(openslp-includes, [  --with-openslp-includes set directory for OpenSLP includes],
+    CFLAGS="-I$withval $CFLAGS"
+    CXXFLAGS="-I$withval $CXXFLAGS"
+    CPPFLAGS="-I$withval $CPPFLAGS",)
+
+LIBSLP=""
+SLPOBJ=""
+
+if test x$enable_slp != xno; then
+    AC_CHECK_HEADER(slp.h,
+        AC_CHECK_LIB(slp, SLPOpen,
+	    AC_DEFINE(HAVE_LIBSLP, 1, [Define to 1 for SLP support])
+	    SLPOBJ="srvreg.o srvloc.o"
+            LIBSLP="-lslp"))
+fi
+
+AC_SUBST(LIBSLP)
+AC_SUBST(SLPOBJ)
+
 AC_CACHE_CHECK([for working socketpair],rsync_cv_HAVE_SOCKETPAIR,[
 AC_RUN_IFELSE([AC_LANG_SOURCE([[
 #ifdef HAVE_SYS_TYPES_H
diff --git a/daemon-parm.txt b/daemon-parm.txt
--- a/daemon-parm.txt
+++ b/daemon-parm.txt
@@ -10,8 +10,10 @@ STRING	socket_options		NULL
 
 INTEGER	listen_backlog		5
 INTEGER	rsync_port|port		0
+INTEGER	slp_refresh		0
 
 BOOL	proxy_protocol		False
+BOOL	use_slp			False
 
 Locals: =================================================================
 
diff --git a/main.c b/main.c
--- a/main.c
+++ b/main.c
@@ -1400,6 +1400,22 @@ static int start_client(int argc, char *argv[])
 
 	if (!read_batch) { /* for read_batch, NO source is specified */
 		char *path = check_for_hostspec(argv[0], &shell_machine, &rsync_port);
+
+		if (shell_machine && !shell_machine[0]) {
+#ifdef HAVE_LIBSLP
+			/* User entered just rsync:// URI */
+			if (lp_use_slp()) {
+				print_service_list();
+				exit_cleanup(0);
+			}
+			rprintf(FINFO, "SLP is disabled, cannot browse\n");
+			exit_cleanup(RERR_SYNTAX);
+#else /* No SLP, die here */
+			rprintf(FINFO, "No SLP support, cannot browse\n");
+			exit_cleanup(RERR_SYNTAX);
+#endif
+		}
+
 		if (path) { /* source is remote */
 			char *dummy_host;
 			int dummy_port = 0;
diff --git a/rsync.1.md b/rsync.1.md
--- a/rsync.1.md
+++ b/rsync.1.md
@@ -152,6 +152,18 @@ rsync daemon by leaving off the module name:
 
 >     rsync somehost.mydomain.com::
 
+And, if Service Location Protocol is available, the following will list the
+available rsync servers:
+
+>     rsync rsync://
+
+See the following section for even more usage details.
+
+One more thing, if Service Location Protocol is available, the following will
+list the available rsync servers:
+
+>     rsync rsync://
+
 ## COPYING TO A DIFFERENT NAME
 
 When you want to copy a directory to a different name, use a trailing slash on
diff --git a/rsync.h b/rsync.h
--- a/rsync.h
+++ b/rsync.h
@@ -235,6 +235,10 @@
 #define SIGNIFICANT_ITEM_FLAGS (~(\
 	ITEM_BASIS_TYPE_FOLLOWS | ITEM_XNAME_FOLLOWS | ITEM_LOCAL_CHANGE))
 
+/* this is the minimum we'll use, irrespective of config setting */
+/* definitely don't set to less than about 30 seconds */
+#define SLP_MIN_TIMEOUT 120
+
 #define CFN_KEEP_DOT_DIRS (1<<0)
 #define CFN_KEEP_TRAILING_SLASH (1<<1)
 #define CFN_DROP_TRAILING_DOT_DIR (1<<2)
diff --git a/rsyncd.conf b/rsyncd.conf
new file mode 100644
--- /dev/null
+++ b/rsyncd.conf
@@ -0,0 +1 @@
+slp refresh = 300
diff --git a/rsyncd.conf.5.md b/rsyncd.conf.5.md
--- a/rsyncd.conf.5.md
+++ b/rsyncd.conf.5.md
@@ -120,6 +120,21 @@ parameters:
     You can override the default backlog value when the daemon listens for
     connections.  It defaults to 5.
 
+0.  `use slp`
+
+    You can enable Service Location Protocol support by enabling this global
+    parameter.  The default is "false".
+
+0.  `slp refresh`
+
+    This parameter is used to determine how long service advertisements are
+    valid (measured in seconds), and is only applicable if you have Service
+    Location Protocol support compiled in. If this is not set or is set to
+    zero, then service advertisements never time out. If this is set to less
+    than 120 seconds, then 120 seconds is used. If it is set to more than
+    65535, then 65535 is used (which is a limitation of SLP).  Using 3600
+    (one hour) is a good number if you tend to change your configuration.
+
 You may also include any [MODULE PARAMETERS](#) in the global part of the
 config file, in which case the supplied value will override the default for
 that parameter.
@@ -1211,6 +1226,7 @@ A more sophisticated example would be:
 > max connections = 4
 > syslog facility = local5
 > pid file = /var/run/rsyncd.pid
+> slp refresh = 3600
 >
 > [ftp]
 >         path = /var/ftp/./pub
diff --git a/socket.c b/socket.c
--- a/socket.c
+++ b/socket.c
@@ -534,6 +534,16 @@ void start_accept_loop(int port, int (*fn)(int, int))
 {
 	fd_set deffds;
 	int *sp, maxfd, i;
+#ifdef HAVE_LIBSLP
+	time_t next_slp_refresh;
+	short slp_timeout = lp_use_slp() ? lp_slp_refresh() : 0;
+	if (slp_timeout) {
+		if (slp_timeout < SLP_MIN_TIMEOUT)
+			slp_timeout = SLP_MIN_TIMEOUT;
+		/* re-register before slp times out */
+		slp_timeout -= 15;
+	}
+#endif
 
 #ifdef HAVE_SIGACTION
 	sigact.sa_flags = SA_NOCLDSTOP;
@@ -561,14 +571,25 @@ void start_accept_loop(int port, int (*fn)(int, int))
 			maxfd = sp[i];
 	}
 
+#ifdef HAVE_LIBSLP
+	next_slp_refresh = time(NULL) + slp_timeout;
+#endif
+
 	/* now accept incoming connections - forking a new process
 	 * for each incoming connection */
 	while (1) {
 		fd_set fds;
 		pid_t pid;
 		int fd;
+		int sel_ret;
 		struct sockaddr_storage addr;
 		socklen_t addrlen = sizeof addr;
+#ifdef HAVE_LIBSLP
+		struct timeval slp_tv;
+
+		slp_tv.tv_sec = 10;
+		slp_tv.tv_usec = 0;
+#endif
 
 		/* close log file before the potentially very long select so
 		 * file can be trimmed by another process instead of growing
@@ -581,7 +602,18 @@ void start_accept_loop(int port, int (*fn)(int, int))
 		fds = deffds;
 #endif
 
-		if (select(maxfd + 1, &fds, NULL, NULL, NULL) < 1)
+#ifdef HAVE_LIBSLP
+		sel_ret = select(maxfd + 1, &fds, NULL, NULL,
+				 slp_timeout ? &slp_tv : NULL);
+		if (sel_ret == 0 && slp_timeout && time(NULL) > next_slp_refresh) {
+			rprintf(FINFO, "Service registration expired, refreshing it\n");
+			register_services();
+			next_slp_refresh = time(NULL) + slp_timeout;
+		}
+#else
+		sel_ret = select(maxfd + 1, &fds, NULL, NULL, NULL);
+#endif
+		if (sel_ret < 1)
 			continue;
 
 		for (i = 0, fd = -1; sp[i] >= 0; i++) {
diff --git a/srvloc.c b/srvloc.c
new file mode 100644
--- /dev/null
+++ b/srvloc.c
@@ -0,0 +1,103 @@
+/* -*- c-file-style: "linux"; -*-
+
+   Copyright (C) 2002 by Brad Hards <bradh@frogmouth.net>
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*/
+
+/* This file implements the service location functionality */
+/* Basically, it uses normal Service Location Protocol API */
+
+/* It is really a cheap hack - just to show how it might work
+   in a real application.
+*/
+
+#include "rsync.h"
+
+#include <slp.h>
+#include <stdio.h>
+#include <string.h>
+
+/* This one just prints out the attributes */
+static SLPBoolean getAttrCallback(UNUSED(SLPHandle hslp), const char *attrlist,
+				  SLPError errcode, UNUSED(void *cookie))
+{
+	char *cleanstr;
+
+	if (errcode == SLP_OK) {
+		if (!strcmp(attrlist, "(comment=)"))
+			rprintf(FINFO, "\t(No description)\n");
+		else {
+			cleanstr = strrchr(attrlist, ')') ;
+			*cleanstr = ' '; /* remove last ')' */
+			rprintf(FINFO, "\t%s\n", strchr(attrlist, '=') + 1);
+		}
+	}
+	return SLP_FALSE;
+}
+
+static SLPBoolean getSLPSrvURLCallback(UNUSED(SLPHandle hslp),
+			const char *srvurl, UNUSED(unsigned short lifetime),
+			SLPError errcode, void *cookie)
+{
+	SLPError    result;
+	SLPHandle   attrhslp;
+
+	if (errcode == SLP_OK) {
+		/* chop service: off the front */
+		rprintf(FINFO, "  %s  ", (strchr(srvurl, ':') + 1));
+		/* check for any attributes */
+		if (SLPOpen("en", SLP_FALSE,&attrhslp) == SLP_OK) {
+			result = SLPFindAttrs(attrhslp, srvurl,
+					      "", /* return all attributes */
+					      "", /* use configured scopes */
+					      getAttrCallback, NULL);
+			if (result != SLP_OK) {
+				rprintf(FERROR, "errorcode: %i\n",result);
+			}
+			SLPClose(attrhslp);
+		}
+		*(SLPError*)cookie = SLP_OK;
+	} else
+		*(SLPError*)cookie = errcode;
+
+	/* Return SLP_TRUE because we want to be called again
+	 * if more services were found. */
+
+	return SLP_TRUE;
+}
+
+int print_service_list(void)
+{
+	SLPError err;
+	SLPError callbackerr;
+	SLPHandle hslp;
+
+	err = SLPOpen("en",SLP_FALSE,&hslp);
+	if (err != SLP_OK) {
+		rprintf(FERROR, "Error opening slp handle %i\n", err);
+		return err;
+	}
+
+	SLPFindSrvs(hslp, "rsync",
+		    0, /* use configured scopes */
+		    0, /* no attr filter        */
+		    getSLPSrvURLCallback, &callbackerr);
+
+	/* Now that we're done using slp, close the slp handle */
+	SLPClose(hslp);
+
+	return 0;
+}
diff --git a/srvreg.c b/srvreg.c
new file mode 100644
--- /dev/null
+++ b/srvreg.c
@@ -0,0 +1,128 @@
+/* -*- c-file-style: "linux"; -*-
+
+   Copyright (C) 2002 by Brad Hards <bradh@frogmouth.net>
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*/
+
+/* This file implements the service registration functionality */
+
+/* Basically, it uses normal Service Location Protocol API */
+
+#include "rsync.h"
+#include "slp.h"
+#include "netdb.h"
+
+extern int rsync_port;
+
+static void slp_callback(UNUSED(SLPHandle hslp), SLPError errcode, void *cookie)
+{
+	/* return the error code in the cookie */
+	*(SLPError*)cookie = errcode;
+
+	/* You could do something else here like print out
+	 * the errcode, etc.  Remember, as a general rule,
+	 * do not try to do too much in a callback because
+	 * it is being executed by the same thread that is
+	 * reading slp packets from the wire. */
+}
+
+int register_services(void)
+{
+	SLPError err, callbackerr;
+	SLPHandle hslp;
+	int n;
+	int i;
+	char srv[120];
+	char attr[120];
+	char localhost[256];
+	extern char *config_file;
+	short timeout;
+	struct addrinfo aih, *ai = 0;
+
+	if (!lp_load(config_file, 0)) {
+		exit_cleanup(RERR_SYNTAX);
+	}
+
+	n = lp_num_modules();
+
+	if (0 == lp_slp_refresh())
+		timeout = SLP_LIFETIME_MAXIMUM; /* don't expire, ever */
+	else if (SLP_MIN_TIMEOUT > lp_slp_refresh())
+		timeout = SLP_MIN_TIMEOUT; /* use a reasonable minimum */
+	else if (SLP_LIFETIME_MAXIMUM <= lp_slp_refresh())
+		timeout = (SLP_LIFETIME_MAXIMUM - 1); /* as long as possible */
+	else
+		timeout = lp_slp_refresh();
+
+	rprintf(FINFO, "rsyncd registering %d service%s with slpd for %d seconds:\n", n, ((n==1)? "":"s"), timeout);
+	err = SLPOpen("en",SLP_FALSE,&hslp);
+	if (err != SLP_OK) {
+		rprintf(FINFO, "Error opening slp handle %i\n",err);
+		return err;
+	}
+	if (gethostname(localhost, sizeof localhost)) {
+	       rprintf(FINFO, "Could not get hostname: %s\n", strerror(errno));
+	       return err;
+	}
+	memset(&aih, 0, sizeof aih);
+	aih.ai_family = PF_UNSPEC;
+	aih.ai_flags = AI_CANONNAME;
+	if (0 != (err = getaddrinfo(localhost, 0, &aih, &ai)) || !ai) {
+	       rprintf(FINFO, "Could not resolve hostname: %s\n", gai_strerror(err));
+	       return err;
+	}
+	/* Register each service with SLP */
+	for (i = 0; i < n; i++) {
+		if (!lp_list(i))
+			continue;
+
+		snprintf(srv, sizeof srv, "service:rsync://%s:%d/%s",
+			 ai->ai_canonname,
+			 rsync_port,
+			 lp_name(i));
+		rprintf(FINFO, "    %s\n", srv);
+		if (lp_comment(i)) {
+			snprintf(attr, sizeof attr, "(comment=%s)",
+				 lp_comment(i));
+		}
+		err = SLPReg(hslp,
+			     srv, /* service to register */
+			     timeout,
+			     0,  /* this is ignored */
+			     attr, /* attributes */
+			     SLP_TRUE, /* new registration - don't change this */
+			     slp_callback, /* callback */
+			     &callbackerr);
+
+		/* err may contain an error code that occurred as the slp library
+		 * _prepared_ to make the call. */
+		if (err != SLP_OK || callbackerr != SLP_OK)
+			rprintf(FINFO, "Error registering service with slp %i\n", err);
+
+		/* callbackerr may contain an error code (that was assigned through
+		 * the callback cookie) that occurred as slp packets were sent on
+		 * the wire. */
+		if (callbackerr != SLP_OK)
+			rprintf(FINFO, "Error registering service with slp %i\n",callbackerr);
+	}
+
+	/* Now that we're done using slp, close the slp handle */
+	freeaddrinfo(ai);
+	SLPClose(hslp);
+
+	/* refresh is done in main select loop */
+	return 0;
+}
diff --git a/usage.c b/usage.c
--- a/usage.c
+++ b/usage.c
@@ -138,6 +138,11 @@ static void print_info_flags(enum logcode f)
 #endif
 			"crtimes",
 
+#ifndef HAVE_LIBSLP
+		"no "
+#endif
+			"SLP",
+
 	"*Optimizations",
 
 #ifndef USE_ROLL_SIMD
diff -Nurp a/config.h.in b/config.h.in
--- a/config.h.in
+++ b/config.h.in
@@ -237,6 +237,9 @@
 /* Define to 1 if you have the `sec' library (-lsec). */
 #undef HAVE_LIBSEC
 
+/* Define to 1 for SLP support */
+#undef HAVE_LIBSLP
+
 /* Define to 1 if you have the `socket' library (-lsocket). */
 #undef HAVE_LIBSOCKET
 
diff -Nurp a/configure.sh b/configure.sh
--- a/configure.sh
+++ b/configure.sh
@@ -660,6 +660,8 @@ BUILD_POPT
 CC_SHOBJ_FLAG
 OBJ_RESTORE
 OBJ_SAVE
+SLPOBJ
+LIBSLP
 ALLOCA
 LIBOBJS
 ROLL_ASM
@@ -766,6 +768,9 @@ enable_zstd
 enable_lz4
 enable_iconv_open
 enable_iconv
+enable_slp
+with_openslp_libs
+with_openslp_includes
 enable_acl_support
 enable_xattr_support
 '
@@ -1422,6 +1427,7 @@ Optional Features:
   --disable-lz4           disable to omit LZ4 compression
   --disable-iconv-open    disable to avoid all use of iconv_open()
   --disable-iconv         disable to omit the --iconv option
+  --disable-slp           turn off SLP support, defaults to on
   --disable-acl-support   disable to omit ACL support
   --disable-xattr-support disable to omit extended attributes
 
@@ -1442,6 +1448,8 @@ Optional Packages:
   --with-nobody-group=GROUP
                           set the default unprivileged group (default nobody
                           or nogroup)
+  --with-openslp-libs     set directory for OpenSLP library
+  --with-openslp-includes set directory for OpenSLP includes
 
 Some influential environment variables:
   CC          C compiler command
@@ -11154,6 +11162,88 @@ printf "%s\n" "#define CAN_HARDLINK_SPEC
 
 fi
 
+# Check whether --enable-slp was given.
+if test ${enable_slp+y}
+then :
+  enableval=$enable_slp;
+fi
+
+
+# Check whether --with-openslp-libs was given.
+if test ${with_openslp_libs+y}
+then :
+  withval=$with_openslp_libs; LDFLAGS="-L$withval $LDFLAGS"
+    DSOFLAGS="-L$withval $DSOFLAGS"
+fi
+
+
+# Check whether --with-openslp-includes was given.
+if test ${with_openslp_includes+y}
+then :
+  withval=$with_openslp_includes; CFLAGS="-I$withval $CFLAGS"
+    CXXFLAGS="-I$withval $CXXFLAGS"
+    CPPFLAGS="-I$withval $CPPFLAGS"
+fi
+
+
+LIBSLP=""
+SLPOBJ=""
+
+if test x$enable_slp != xno; then
+    ac_fn_c_check_header_compile "$LINENO" "slp.h" "ac_cv_header_slp_h" "$ac_includes_default"
+if test "x$ac_cv_header_slp_h" = xyes
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for SLPOpen in -lslp" >&5
+printf %s "checking for SLPOpen in -lslp... " >&6; }
+if test ${ac_cv_lib_slp_SLPOpen+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lslp  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+char SLPOpen ();
+int
+main (void)
+{
+return SLPOpen ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  ac_cv_lib_slp_SLPOpen=yes
+else $as_nop
+  ac_cv_lib_slp_SLPOpen=no
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_slp_SLPOpen" >&5
+printf "%s\n" "$ac_cv_lib_slp_SLPOpen" >&6; }
+if test "x$ac_cv_lib_slp_SLPOpen" = xyes
+then :
+
+printf "%s\n" "#define HAVE_LIBSLP 1" >>confdefs.h
+
+	    SLPOBJ="srvreg.o srvloc.o"
+            LIBSLP="-lslp"
+fi
+
+fi
+
+fi
+
+
+
+
 { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for working socketpair" >&5
 printf %s "checking for working socketpair... " >&6; }
 if test ${rsync_cv_HAVE_SOCKETPAIR+y}
diff -Nurp a/rrsync.1 b/rrsync.1
--- a/rrsync.1
+++ b/rrsync.1
@@ -1,176 +0,0 @@
-.TH "rrsync" "1" "15 Jan 2025" "rrsync from rsync 3.4.1" "User Commands"
-.\" prefix=/usr
-.P
-.SH "NAME"
-.P
-rrsync \- a script to setup restricted rsync users via ssh logins
-.P
-.SH "SYNOPSIS"
-.P
-.nf
-rrsync [-ro|-wo] [-munge] [-no-del] [-no-lock] [-no-overwrite]  DIR
-.fi
-.P
-The single non-option argument specifies the restricted \fIDIR\fP to use. It can be
-relative to the user's home directory or an absolute path.
-.P
-The online version of this manpage (that includes cross-linking of topics)
-is available at
-.UR https://download.samba.org/pub/rsync/rrsync.1
-.UE .
-.P
-.SH "DESCRIPTION"
-.P
-A user's ssh login can be restricted to only allow the running of an rsync
-transfer in one of two easy ways:
-.P
-.IP o
-forcing the running of the rrsync script
-.IP o
-forcing the running of an rsync daemon-over-ssh command.
-.P
-Both of these setups use a feature of ssh that allows a command to be forced to
-run instead of an interactive shell.  However, if the user's home shell is bash,
-please see BASH SECURITY ISSUE for a potential issue.
-.P
-To use the rrsync script, edit the user's \fB~/.ssh/authorized_keys\fP file and add
-a prefix like one of the following (followed by a space) in front of each
-ssh-key line that should be restricted:
-.RS 4
-.P
-.nf
-command="rrsync DIR"
-command="rrsync -ro DIR"
-command="rrsync -munge -no-del DIR"
-.fi
-.RE
-.P
-Then, ensure that the rrsync script has your desired option restrictions. You
-may want to copy the script to a local bin dir with a unique name if you want
-to have multiple configurations. One or more rrsync options can be specified
-prior to the \fIDIR\fP if you want to further restrict the transfer.
-.P
-To use an rsync daemon setup, edit the user's \fB~/.ssh/authorized_keys\fP file and
-add a prefix like one of the following (followed by a space) in front of each
-ssh-key line that should be restricted:
-.RS 4
-.P
-.nf
-command="rsync --server --daemon ."
-command="rsync --server --daemon --config=/PATH/TO/rsyncd.conf ."
-.fi
-.RE
-.P
-Then, ensure that the rsyncd.conf file is created with one or more module names
-with the appropriate path and option restrictions.  If rsync's
-\fB\-\-config\fP option is omitted, it defaults to \fB~/rsyncd.conf\fP.
-See the \fBrsyncd.conf\fP(5) manpage for details of how to
-configure an rsync daemon.
-.P
-When using rrsync, there can be just one restricted dir per authorized key.  A
-daemon setup, on the other hand, allows multiple module names inside the config
-file, each one with its own path setting.
-.P
-The remainder of this manpage is dedicated to using the rrsync script.
-.P
-.SH "OPTIONS"
-.P
-.IP "\fB\-ro\fP"
-Allow only reading from the DIR. Implies \fB\-no-del\fP and
-\fB\-no-lock\fP.
-.IP "\fB\-wo\fP"
-Allow only writing to the DIR.
-.IP "\fB\-munge\fP"
-Enable rsync's \fB\-\-munge-links\fP on the server side.
-.IP "\fB\-no-del\fP"
-Disable rsync's \fB\-\-delete*\fP and \fB\-\-remove*\fP options.
-.IP "\fB\-no-lock\fP"
-Avoid the single-run (per-user) lock check.  Useful with \fB\-munge\fP.
-.IP "\fB\-no-overwrite\fP"
-Enforce \fB\-\-ignore-existing\fP on the server. Prevents overwriting existing
-files when the server is the receiver.
-.IP "\fB\-help\fP, \fB\-h\fP"
-Output this help message and exit.
-.P
-.SH "SECURITY RESTRICTIONS"
-.P
-The rrsync script validates the path arguments it is sent to try to restrict
-them to staying within the specified DIR.
-.P
-The rrsync script rejects rsync's \fB\-\-copy-links\fP option (by
-default) so that a copy cannot dereference a symlink within the DIR to get to a
-file outside the DIR.
-.P
-The rrsync script rejects rsync's \fB\-\-protect-args\fP (\fB\-s\fP) option
-because it would allow options to be sent to the server-side that the script
-cannot check.  If you want to support \fB\-\-protect-args\fP, use a daemon-over-ssh
-setup.
-.P
-The rrsync script accepts just a subset of rsync's options that the real rsync
-uses when running the server command.  A few extra convenience options are also
-included to help it to interact with BackupPC and accept some convenient user
-overrides.
-.P
-The script (or a copy of it) can be manually edited if you want it to customize
-the option handling.
-.P
-.SH "BASH SECURITY ISSUE"
-.P
-If your users have bash set as their home shell, bash may try to be overly
-helpful and ensure that the user's login bashrc files are run prior to
-executing the forced command.  This can be a problem if the user can somehow
-update their home bashrc files, perhaps via the restricted copy, a shared home
-directory, or something similar.
-.P
-One simple way to avoid the issue is to switch the user to a simpler shell,
-such as dash.  When choosing the new home shell, make sure that you're not
-choosing bash in disguise, as it is unclear if it avoids the security issue.
-.P
-Another potential fix is to ensure that the user's home directory is not a
-shared mount and that they have no means of copying files outside of their
-restricted directories.  This may require you to force the enabling of symlink
-munging on the server side.
-.P
-A future version of openssh may have a change to the handling of forced
-commands that allows it to avoid using the user's home shell.
-.P
-.SH "EXAMPLES"
-.P
-The \fB~/.ssh/authorized_keys\fP file might have lines in it like this:
-.RS 4
-.P
-.nf
-command="rrsync client/logs" ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAIEAzG...
-command="rrsync -ro results" ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAIEAmk...
-.fi
-.RE
-.P
-.SH "FILES"
-.P
-~/.ssh/authorized_keys
-.P
-.SH "SEE ALSO"
-.P
-\fBrsync\fP(1), \fBrsyncd.conf\fP(5)
-.P
-.SH "VERSION"
-.P
-This manpage is current for version 3.4.1 of rsync.
-.P
-.SH "CREDITS"
-.P
-rsync is distributed under the GNU General Public License.  See the file
-COPYING for details.
-.P
-An rsync web site is available at
-.UR https://rsync.samba.org/
-.UE
-and its github
-project is
-.UR https://github.com/RsyncProject/rsync
-.UE .
-.P
-.SH "AUTHOR"
-.P
-The original rrsync perl script was written by Joe Smith.  Many people have
-later contributed to it.  The python version was created by Wayne Davison.
diff -Nurp a/rrsync.1.html b/rrsync.1.html
--- a/rrsync.1.html
+++ b/rrsync.1.html
@@ -1,169 +0,0 @@
-<html><head>
-<title>rrsync(1) manpage</title>
-<meta charset="UTF-8"/>
-<link href="https://fonts.googleapis.com/css2?family=Roboto&family=Roboto+Mono&display=swap" rel="stylesheet">
-<style>
-body {
-  max-width: 50em;
-  margin: auto;
-}
-body, b, strong, u {
-  font-family: 'Roboto', sans-serif;
-}
-a.tgt { font-face: symbol; font-weight: 400; font-size: 70%; visibility: hidden; text-decoration: none; color: #ddd; padding: 0 4px; border: 0; }
-a.tgt:after { content: 'ðŸ”—'; }
-a.tgt:hover { color: #444; background-color: #eaeaea; }
-h1:hover > a.tgt, h2:hover > a.tgt, h3:hover > a.tgt, dt:hover > a.tgt { visibility: visible; }
-code {
-  font-family: 'Roboto Mono', monospace;
-  font-weight: bold;
-  white-space: pre;
-}
-pre code {
-  display: block;
-  font-weight: normal;
-}
-blockquote pre code {
-  background: #f1f1f1;
-}
-dd p:first-of-type {
-  margin-block-start: 0em;
-}
-</style>
-</head><body>
-<h2 id="NAME">NAME<a href="#NAME" class="tgt"></a></h2>
-<p>rrsync -&#8288; a script to setup restricted rsync users via ssh logins</p>
-<h2 id="SYNOPSIS">SYNOPSIS<a href="#SYNOPSIS" class="tgt"></a></h2>
-<pre><code>rrsync [-ro|-wo] [-munge] [-no-del] [-no-lock] [-no-overwrite]  DIR
-</code></pre>
-<p>The single non-option argument specifies the restricted <u>DIR</u> to use. It can be
-relative to the user's home directory or an absolute path.</p>
-<p>The online version of this manpage (that includes cross-linking of topics)
-is available at <a href="https://download.samba.org/pub/rsync/rrsync.1">https://download.samba.org/pub/rsync/rrsync.1</a>.</p>
-<h2 id="DESCRIPTION">DESCRIPTION<a href="#DESCRIPTION" class="tgt"></a></h2>
-<p>A user's ssh login can be restricted to only allow the running of an rsync
-transfer in one of two easy ways:</p>
-<ul>
-<li>forcing the running of the rrsync script</li>
-<li>forcing the running of an rsync daemon-over-ssh command.</li>
-</ul>
-<p>Both of these setups use a feature of ssh that allows a command to be forced to
-run instead of an interactive shell.  However, if the user's home shell is bash,
-please see <a href="#BASH_SECURITY_ISSUE">BASH SECURITY ISSUE</a> for a potential issue.</p>
-<p>To use the rrsync script, edit the user's <code>~/.ssh/authorized_keys</code> file and add
-a prefix like one of the following (followed by a space) in front of each
-ssh-key line that should be restricted:</p>
-<blockquote>
-<pre><code>command=&quot;rrsync DIR&quot;
-command=&quot;rrsync -ro DIR&quot;
-command=&quot;rrsync -munge -no-del DIR&quot;
-</code></pre>
-</blockquote>
-<p>Then, ensure that the rrsync script has your desired option restrictions. You
-may want to copy the script to a local bin dir with a unique name if you want
-to have multiple configurations. One or more rrsync options can be specified
-prior to the <u>DIR</u> if you want to further restrict the transfer.</p>
-<p>To use an rsync daemon setup, edit the user's <code>~/.ssh/authorized_keys</code> file and
-add a prefix like one of the following (followed by a space) in front of each
-ssh-key line that should be restricted:</p>
-<blockquote>
-<pre><code>command=&quot;rsync --server --daemon .&quot;
-command=&quot;rsync --server --daemon --config=/PATH/TO/rsyncd.conf .&quot;
-</code></pre>
-</blockquote>
-<p>Then, ensure that the rsyncd.conf file is created with one or more module names
-with the appropriate path and option restrictions.  If rsync's
-<a href="rsync.1#dopt--config"><code>--config</code></a> option is omitted, it defaults to <code>~/rsyncd.conf</code>.
-See the <a href="rsyncd.conf.5"><strong>rsyncd.conf</strong>(5)</a> manpage for details of how to
-configure an rsync daemon.</p>
-<p>When using rrsync, there can be just one restricted dir per authorized key.  A
-daemon setup, on the other hand, allows multiple module names inside the config
-file, each one with its own path setting.</p>
-<p>The remainder of this manpage is dedicated to using the rrsync script.</p>
-<h2 id="OPTIONS">OPTIONS<a href="#OPTIONS" class="tgt"></a></h2>
-<dl>
-
-<dt id="opt-ro"><code>-ro</code><a href="#opt-ro" class="tgt"></a></dt><dd>
-<p>Allow only reading from the DIR. Implies <a href="#opt-no-del"><code>-no-del</code></a> and
-<a href="#opt-no-lock"><code>-no-lock</code></a>.</p>
-</dd>
-
-<dt id="opt-wo"><code>-wo</code><a href="#opt-wo" class="tgt"></a></dt><dd>
-<p>Allow only writing to the DIR.</p>
-</dd>
-
-<dt id="opt-munge"><code>-munge</code><a href="#opt-munge" class="tgt"></a></dt><dd>
-<p>Enable rsync's <a href="rsync.1#opt--munge-links"><code>--munge-links</code></a> on the server side.</p>
-</dd>
-
-<dt id="opt-no-del"><code>-no-del</code><a href="#opt-no-del" class="tgt"></a></dt><dd>
-<p>Disable rsync's <code>--delete*</code> and <code>--remove*</code> options.</p>
-</dd>
-
-<dt id="opt-no-lock"><code>-no-lock</code><a href="#opt-no-lock" class="tgt"></a></dt><dd>
-<p>Avoid the single-run (per-user) lock check.  Useful with <a href="#opt-munge"><code>-munge</code></a>.</p>
-</dd>
-
-<dt id="opt-no-overwrite"><code>-no-overwrite</code><a href="#opt-no-overwrite" class="tgt"></a></dt><dd>
-<p>Enforce <code>--ignore-existing</code> on the server. Prevents overwriting existing
-files when the server is the receiver.</p>
-</dd>
-
-<span id="opt-h"></span><dt id="opt-help"><code>-help</code>, <code>-h</code><a href="#opt-help" class="tgt"></a></dt><dd>
-<p>Output this help message and exit.</p>
-</dd>
-</dl>
-<h2 id="SECURITY_RESTRICTIONS">SECURITY RESTRICTIONS<a href="#SECURITY_RESTRICTIONS" class="tgt"></a></h2>
-<p>The rrsync script validates the path arguments it is sent to try to restrict
-them to staying within the specified DIR.</p>
-<p>The rrsync script rejects rsync's <a href="rsync.1#opt--copy-links"><code>--copy-links</code></a> option (by
-default) so that a copy cannot dereference a symlink within the DIR to get to a
-file outside the DIR.</p>
-<p>The rrsync script rejects rsync's <a href="rsync.1#opt--protect-args"><code>--protect-args</code></a> (<code>-s</code>) option
-because it would allow options to be sent to the server-side that the script
-cannot check.  If you want to support <code>--protect-args</code>, use a daemon-over-ssh
-setup.</p>
-<p>The rrsync script accepts just a subset of rsync's options that the real rsync
-uses when running the server command.  A few extra convenience options are also
-included to help it to interact with BackupPC and accept some convenient user
-overrides.</p>
-<p>The script (or a copy of it) can be manually edited if you want it to customize
-the option handling.</p>
-<h2 id="BASH_SECURITY_ISSUE">BASH SECURITY ISSUE<a href="#BASH_SECURITY_ISSUE" class="tgt"></a></h2>
-<p>If your users have bash set as their home shell, bash may try to be overly
-helpful and ensure that the user's login bashrc files are run prior to
-executing the forced command.  This can be a problem if the user can somehow
-update their home bashrc files, perhaps via the restricted copy, a shared home
-directory, or something similar.</p>
-<p>One simple way to avoid the issue is to switch the user to a simpler shell,
-such as dash.  When choosing the new home shell, make sure that you're not
-choosing bash in disguise, as it is unclear if it avoids the security issue.</p>
-<p>Another potential fix is to ensure that the user's home directory is not a
-shared mount and that they have no means of copying files outside of their
-restricted directories.  This may require you to force the enabling of symlink
-munging on the server side.</p>
-<p>A future version of openssh may have a change to the handling of forced
-commands that allows it to avoid using the user's home shell.</p>
-<h2 id="EXAMPLES">EXAMPLES<a href="#EXAMPLES" class="tgt"></a></h2>
-<p>The <code>~/.ssh/authorized_keys</code> file might have lines in it like this:</p>
-<blockquote>
-<pre><code>command=&quot;rrsync client/logs&quot; ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAIEAzG...
-command=&quot;rrsync -ro results&quot; ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAIEAmk...
-</code></pre>
-</blockquote>
-<h2 id="FILES">FILES<a href="#FILES" class="tgt"></a></h2>
-<p>~/.ssh/authorized_keys</p>
-<h2 id="SEE_ALSO">SEE ALSO<a href="#SEE_ALSO" class="tgt"></a></h2>
-<p><a href="rsync.1"><strong>rsync</strong>(1)</a>, <a href="rsyncd.conf.5"><strong>rsyncd.conf</strong>(5)</a></p>
-<h2 id="VERSION">VERSION<a href="#VERSION" class="tgt"></a></h2>
-<p>This manpage is current for version 3.4.1 of rsync.</p>
-<h2 id="CREDITS">CREDITS<a href="#CREDITS" class="tgt"></a></h2>
-<p>rsync is distributed under the GNU General Public License.  See the file
-<a href="COPYING">COPYING</a> for details.</p>
-<p>An rsync web site is available at <a href="https://rsync.samba.org/">https://rsync.samba.org/</a> and its github
-project is <a href="https://github.com/RsyncProject/rsync">https://github.com/RsyncProject/rsync</a>.</p>
-<h2 id="AUTHOR">AUTHOR<a href="#AUTHOR" class="tgt"></a></h2>
-<p>The original rrsync perl script was written by Joe Smith.  Many people have
-later contributed to it.  The python version was created by Wayne Davison.</p>
-<div style="float: right"><p><i>15 Jan 2025</i></p></div>
-</body></html>
diff -Nurp a/rsync.1 b/rsync.1
--- a/rsync.1
+++ b/rsync.1
@@ -1,5 +1,5 @@
 .TH "rsync" "1" "15 Jan 2025" "rsync 3.4.1" "User Commands"
-.\" prefix=/usr
+.\" prefix=/usr/local
 .P
 .SH "NAME"
 .P
@@ -188,6 +188,26 @@ rsync somehost.mydomain.com::
 .fi
 .RE
 .P
+And, if Service Location Protocol is available, the following will list the
+available rsync servers:
+.RS 4
+.P
+.nf
+rsync rsync://
+.fi
+.RE
+.P
+See the following section for even more usage details.
+.P
+One more thing, if Service Location Protocol is available, the following will
+list the available rsync servers:
+.RS 4
+.P
+.nf
+rsync rsync://
+.fi
+.RE
+.P
 .SH "COPYING TO A DIFFERENT NAME"
 .P
 When you want to copy a directory to a different name, use a trailing slash on
diff -Nurp a/rsync.1.html b/rsync.1.html
--- a/rsync.1.html
+++ b/rsync.1.html
@@ -167,6 +167,19 @@ rsync daemon by leaving off the module n
 <pre><code>rsync somehost.mydomain.com::
 </code></pre>
 </blockquote>
+<p>And, if Service Location Protocol is available, the following will list the
+available rsync servers:</p>
+<blockquote>
+<pre><code>rsync rsync://
+</code></pre>
+</blockquote>
+<p>See the following section for even more usage details.</p>
+<p>One more thing, if Service Location Protocol is available, the following will
+list the available rsync servers:</p>
+<blockquote>
+<pre><code>rsync rsync://
+</code></pre>
+</blockquote>
 <h2 id="COPYING_TO_A_DIFFERENT_NAME">COPYING TO A DIFFERENT NAME<a href="#COPYING_TO_A_DIFFERENT_NAME" class="tgt"></a></h2>
 <p>When you want to copy a directory to a different name, use a trailing slash on
 the source directory to put the contents of the directory into any destination
diff -Nurp a/rsyncd.conf.5 b/rsyncd.conf.5
--- a/rsyncd.conf.5
+++ b/rsyncd.conf.5
@@ -1,5 +1,5 @@
 .TH "rsyncd.conf" "5" "15 Jan 2025" "rsyncd.conf from rsync 3.4.1" "User Commands"
-.\" prefix=/usr
+.\" prefix=/usr/local
 .P
 .SH "NAME"
 .P
@@ -73,11 +73,11 @@ and a single line something like this to
 .RS 4
 .P
 .nf
-rsync   stream  tcp     nowait  root   /usr/bin/rsync rsyncd --daemon
+rsync   stream  tcp     nowait  root   /usr/local/bin/rsync rsyncd --daemon
 .fi
 .RE
 .P
-Replace "/usr/bin/rsync" with the path to where you have rsync installed on
+Replace "/usr/local/bin/rsync" with the path to where you have rsync installed on
 your system.  You will then need to send inetd a HUP signal to tell it to
 reread its config file.
 .P
@@ -119,6 +119,17 @@ can also be specified via the \fB\-\-soc
 .IP "\fBlisten\ backlog\fP"
 You can override the default backlog value when the daemon listens for
 connections.  It defaults to 5.
+.IP "\fBuse\ slp\fP"
+You can enable Service Location Protocol support by enabling this global
+parameter.  The default is "false".
+.IP "\fBslp\ refresh\fP"
+This parameter is used to determine how long service advertisements are
+valid (measured in seconds), and is only applicable if you have Service
+Location Protocol support compiled in. If this is not set or is set to
+zero, then service advertisements never time out. If this is set to less
+than 120 seconds, then 120 seconds is used. If it is set to more than
+65535, then 65535 is used (which is a limitation of SLP).  Using 3600
+(one hour) is a good number if you tend to change your configuration.
 .P
 You may also include any MODULE PARAMETERS in the global part of the
 config file, in which case the supplied value will override the default for
@@ -1248,6 +1259,7 @@ use chroot = yes
 max connections = 4
 syslog facility = local5
 pid file = /var/run/rsyncd.pid
+slp refresh = 3600
 
 [ftp]
         path = /var/ftp/./pub
diff -Nurp a/rsyncd.conf.5.html b/rsyncd.conf.5.html
--- a/rsyncd.conf.5.html
+++ b/rsyncd.conf.5.html
@@ -77,10 +77,10 @@ command &quot;<code>rsync --daemon</code
 </blockquote>
 <p>and a single line something like this to /etc/inetd.conf:</p>
 <blockquote>
-<pre><code>rsync   stream  tcp     nowait  root   /usr/bin/rsync rsyncd --daemon
+<pre><code>rsync   stream  tcp     nowait  root   /usr/local/bin/rsync rsyncd --daemon
 </code></pre>
 </blockquote>
-<p>Replace &quot;/usr/bin/rsync&quot; with the path to where you have rsync installed on
+<p>Replace &quot;/usr/local/bin/rsync&quot; with the path to where you have rsync installed on
 your system.  You will then need to send inetd a HUP signal to tell it to
 reread its config file.</p>
 <p>Note that you should <strong>not</strong> send the rsync daemon a HUP signal to force it to
@@ -130,6 +130,21 @@ can also be specified via the <code>--so
 <p>You can override the default backlog value when the daemon listens for
 connections.  It defaults to 5.</p>
 </dd>
+
+<dt id="use_slp"><code>use slp</code><a href="#use_slp" class="tgt"></a></dt><dd>
+<p>You can enable Service Location Protocol support by enabling this global
+parameter.  The default is &quot;false&quot;.</p>
+</dd>
+
+<dt id="slp_refresh"><code>slp refresh</code><a href="#slp_refresh" class="tgt"></a></dt><dd>
+<p>This parameter is used to determine how long service advertisements are
+valid (measured in seconds), and is only applicable if you have Service
+Location Protocol support compiled in. If this is not set or is set to
+zero, then service advertisements never time out. If this is set to less
+than 120 seconds, then 120 seconds is used. If it is set to more than
+65535, then 65535 is used (which is a limitation of SLP).  Using 3600
+(one hour) is a good number if you tend to change your configuration.</p>
+</dd>
 </dl>
 <p>You may also include any <a href="#MODULE_PARAMETERS">MODULE PARAMETERS</a> in the global part of the
 config file, in which case the supplied value will override the default for
@@ -1153,6 +1168,7 @@ use chroot = yes
 max connections = 4
 syslog facility = local5
 pid file = /var/run/rsyncd.pid
+slp refresh = 3600
 
 [ftp]
         path = /var/ftp/./pub
diff -Nurp a/rsync-ssl.1 b/rsync-ssl.1
--- a/rsync-ssl.1
+++ b/rsync-ssl.1
@@ -1,5 +1,5 @@
 .TH "rsync-ssl" "1" "15 Jan 2025" "rsync-ssl from rsync 3.4.1" "User Commands"
-.\" prefix=/usr
+.\" prefix=/usr/local
 .P
 .SH "NAME"
 .P
